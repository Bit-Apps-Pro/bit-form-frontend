/*!
 * virtualized-list v2.2.0 - https://github.com/clauderic/virtualized-list
 * MIT Licensed
 */
!(function (t, e) { typeof exports === 'object' && typeof module === 'object' ? module.exports = e() : typeof define === 'function' && define.amd ? define([], e) : typeof exports === 'object' ? exports.VirtualizedList = e() : t.VirtualizedList = e() }(this, () => (function (t) { function e(i) { if (n[i]) return n[i].exports; const o = n[i] = { i, l: !1, exports: {} }; return t[i].call(o.exports, o, o.exports, e), o.l = !0, o.exports } var n = {}; return e.m = t, e.c = n, e.i = function (t) { return t }, e.d = function (t, n, i) { e.o(t, n) || Object.defineProperty(t, n, { configurable: !1, enumerable: !0, get: i }) }, e.n = function (t) { const n = t && t.__esModule ? function () { return t.default } : function () { return t }; return e.d(n, 'a', n), n }, e.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e) }, e.p = '', e(e.s = 5) }([function (t, e, n) {
  function i(t, e) { if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function') } const o = n(4); const r = n.n(o); const
    a = n(3); n.d(e, 'a', () => u); const s = 'position:relative; overflow:hidden; width:100%; min-height:100%; will-change: transform;'
  const d = 'position:absolute; top:0; left:0; height:100%; width:100%; overflow:visible;'
  var u = (function () {
    function t(e, n) {
      const o = this; i(this, t), this.getRowHeight = function (t) {
        const e = t.index; const
          n = o.options.rowHeight; return typeof n === 'function' ? n(e) : Array.isArray(n) ? n[e] : n
      }, this.container = e, this.options = n, this.state = {}, this._initializeSizeAndPositionManager(n.rowCount), this.render = this.render.bind(this), this.handleScroll = this.handleScroll.bind(this), this.componentDidMount()
    } return t.prototype.componentDidMount = function () {
      const t = this; const e = this.options; const n = e.onMount; const i = e.initialScrollTop; const o = e.initialIndex; const r = e.height; const a = i || o != null && this.getRowOffset(o) || 0; const u = this.inner = document.createElement('div'); const
        f = this.content = document.createElement('div'); u.setAttribute('style', s), f.setAttribute('style', d), u.appendChild(f), this.container.appendChild(u), this.setState({ offset: a, height: r }, () => { a && (t.container.scrollTop = a), t.container.addEventListener('scroll', t.handleScroll), typeof n === 'function' && n() })
    }, t.prototype._initializeSizeAndPositionManager = function (t) { this._sizeAndPositionManager = new a.a({ itemCount: t, itemSizeGetter: this.getRowHeight, estimatedItemSize: this.options.estimatedRowHeight || 100 }) }, t.prototype.setState = function () {
      const t = this; const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const
        n = arguments[1]; this.state = Object.assign(this.state, e), requestAnimationFrame(() => { t.render(), typeof n === 'function' && n() })
    }, t.prototype.resize = function (t, e) { this.setState({ height: t }, e) }, t.prototype.handleScroll = function (t) {
      const e = this.options.onScroll; const
        n = this.container.scrollTop; this.setState({ offset: n }), typeof e === 'function' && e(n, t)
    }, t.prototype.getRowOffset = function (t) { return this._sizeAndPositionManager.getSizeAndPositionForIndex(t).offset }, t.prototype.scrollToIndex = function (t, e) {
      const n = this.state.height; const
        i = this._sizeAndPositionManager.getUpdatedOffsetForIndex({ align: e, containerSize: n, targetIndex: t }); this.container.scrollTop = i
    }, t.prototype.setRowCount = function (t) { this._initializeSizeAndPositionManager(t), this.render() }, t.prototype.onRowsRendered = function t(e) { const t = this.options.onRowsRendered; typeof t === 'function' && t(e) }, t.prototype.destroy = function () { this.container.removeEventListener('scroll', this.handleScroll), this.container.innerHTML = '' }, t.prototype.render = function () { for (var t = this.options, e = t.overscanCount, n = t.renderRow, i = this.state, o = i.height, a = i.offset, s = void 0 === a ? 0 : a, d = this._sizeAndPositionManager.getVisibleRange({ containerSize: o, offset: s, overscanCount: e }), u = d.start, f = d.stop, l = document.createDocumentFragment(), c = u; c <= f; c++)l.appendChild(n(c)); this.inner.style.height = `${this._sizeAndPositionManager.getTotalSize() }px`, this.content.style.top = `${this.getRowOffset(u) }px`, r()(this.content, l, { childrenOnly: !0, getNodeKey(t) { return t.nodeIndex } }), this.onRowsRendered({ startIndex: u, stopIndex: f }) }, t
  }())
}, function (t, e, n) {
  Object.defineProperty(e, '__esModule', { value: !0 }); const i = n(0); n.d(e, 'default', () => i.a); const o = n(2); n.d(e, 'InfiniteVirtualList', () => o.a)
}, function (t, e, n) {
  function i(t, e) { if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function') } function o(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || typeof e !== 'object' && typeof e !== 'function' ? t : e } function r(t, e) { if (typeof e !== 'function' && e !== null) throw new TypeError(`Super expression must either be null or a function, not ${ typeof e}`); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) } function a(t) {
    const e = t.lastRenderedStartIndex; const n = t.lastRenderedStopIndex; const i = t.startIndex; const
      o = t.stopIndex; return !(i > n || o < e)
  } function s(t) { for (var e = t.isRowLoaded, n = t.minimumBatchSize, i = t.rowCount, o = t.startIndex, r = t.stopIndex, a = [], s = null, d = null, u = o; u <= r; u++) { e(u) ? d !== null && (a.push({ startIndex: s, stopIndex: d }), s = d = null) : (d = u, s === null && (s = u)) } if (d !== null) { for (let f = Math.min(Math.max(d, s + n - 1), i - 1), l = d + 1; l <= f && !e({ index: l }); l++)d = l; a.push({ startIndex: s, stopIndex: d }) } if (a.length) for (let c = a[0]; c.stopIndex - c.startIndex + 1 < n && c.startIndex > 0;) { const h = c.startIndex - 1; if (e({ index: h })) break; c.startIndex = h } return a } const d = n(0); n.d(e, 'a', () => u); var u = (function (t) {
    function e() { return i(this, e), o(this, t.apply(this, arguments)) } return r(e, t), e.prototype.onRowsRendered = function (t) {
      const e = this; const n = t.startIndex; const i = t.stopIndex; const o = this.options; const r = o.isRowLoaded; const d = o.loadMoreRows; const u = o.minimumBatchSize; const f = void 0 === u ? 10 : u; const l = o.rowCount; const c = void 0 === l ? 0 : l; const h = o.threshold; const
        p = void 0 === h ? 15 : h; s({ isRowLoaded: r, minimumBatchSize: f, rowCount: c, startIndex: Math.max(0, n - p), stopIndex: Math.min(c - 1, i + p) }).forEach((t) => { const o = d(t); o && o.then(() => { a({ lastRenderedStartIndex: n, lastRenderedStopIndex: i, startIndex: t.startIndex, stopIndex: t.stopIndex }) && e.render() }) })
    }, e
  }(d.a))
}, function (t, e, n) {
  function i(t, e) { if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function') } n.d(e, 'a', () => s); const o = 'start'
  const r = 'center'
  const a = 'end'
  var s = (function () {
    function t(e) {
      const n = e.itemCount; const o = e.itemSizeGetter; const
        r = e.estimatedItemSize; i(this, t), this._itemSizeGetter = o, this._itemCount = n, this._estimatedItemSize = r, this._itemSizeAndPositionData = {}, this._lastMeasuredIndex = -1
    } return t.prototype.getLastMeasuredIndex = function () { return this._lastMeasuredIndex }, t.prototype.getSizeAndPositionForIndex = function (t) { if (t < 0 || t >= this._itemCount) throw Error(`Requested index ${ t } is outside of range 0..${ this._itemCount}`); if (t > this._lastMeasuredIndex) { for (let e = this.getSizeAndPositionOfLastMeasuredItem(), n = e.offset + e.size, i = this._lastMeasuredIndex + 1; i <= t; i++) { const o = this._itemSizeGetter({ index: i }); if (o == null || isNaN(o)) throw Error(`Invalid size returned for index ${ i } of value ${ o}`); this._itemSizeAndPositionData[i] = { offset: n, size: o }, n += o } this._lastMeasuredIndex = t } return this._itemSizeAndPositionData[t] }, t.prototype.getSizeAndPositionOfLastMeasuredItem = function () { return this._lastMeasuredIndex >= 0 ? this._itemSizeAndPositionData[this._lastMeasuredIndex] : { offset: 0, size: 0 } }, t.prototype.getTotalSize = function () { const t = this.getSizeAndPositionOfLastMeasuredItem(); return t.offset + t.size + (this._itemCount - this._lastMeasuredIndex - 1) * this._estimatedItemSize }, t.prototype.getUpdatedOffsetForIndex = function (t) {
      const e = t.align; const n = void 0 === e ? o : e; const i = t.containerSize; const
        s = t.targetIndex; if (i <= 0) return 0; const d = this.getSizeAndPositionForIndex(s); const u = d.offset; const f = u - i + d.size; let
        l = void 0; switch (n) { case a: l = f; break; case r: l = u - (i - d.size) / 2; break; default: l = u } const c = this.getTotalSize(); return Math.max(0, Math.min(c - i, l))
    }, t.prototype.getVisibleRange = function (t) {
      const e = t.containerSize; let n = t.offset; const
        i = t.overscanCount; if (this.getTotalSize() === 0) return {}; const o = n + e; let r = this._findNearestItem(n); let a = r; const
        s = this.getSizeAndPositionForIndex(r); for (n = s.offset + s.size; n < o && a < this._itemCount - 1;)a++, n += this.getSizeAndPositionForIndex(a).size; return i && (r = Math.max(0, r - i), a = Math.min(a + i, this._itemCount)), { start: r, stop: a }
    }, t.prototype.resetItem = function (t) { this._lastMeasuredIndex = Math.min(this._lastMeasuredIndex, t - 1) }, t.prototype._binarySearch = function (t) { for (var e = t.low, n = t.high, i = t.offset, o = void 0, r = void 0; e <= n;) { if (o = e + Math.floor((n - e) / 2), (r = this.getSizeAndPositionForIndex(o).offset) === i) return o; r < i ? e = o + 1 : r > i && (n = o - 1) } if (e > 0) return e - 1 }, t.prototype._exponentialSearch = function (t) { for (var e = t.index, n = t.offset, i = 1; e < this._itemCount && this.getSizeAndPositionForIndex(e).offset < n;)e += i, i *= 2; return this._binarySearch({ high: Math.min(e, this._itemCount - 1), low: Math.floor(e / 2), offset: n }) }, t.prototype._findNearestItem = function (t) {
      if (isNaN(t)) throw Error(`Invalid offset ${ t } specified`); t = Math.max(0, t); const e = this.getSizeAndPositionOfLastMeasuredItem(); const
        n = Math.max(0, this._lastMeasuredIndex); return e.offset >= t ? this._binarySearch({ high: n, low: 0, offset: t }) : this._exponentialSearch({ index: n, offset: t })
    }, t
  }())
}, function (t, e, n) {
  function i(t) { !c && m.createRange && (c = m.createRange(), c.selectNode(m.body)); let e; return c && c.createContextualFragment ? e = c.createContextualFragment(t) : (e = m.createElement('body'), e.innerHTML = t), e.childNodes[0] } function o(t, e) {
    const n = t.nodeName; const
      i = e.nodeName; return n === i || !!(e.actualize && n.charCodeAt(0) < 91 && i.charCodeAt(0) > 90) && n === i.toUpperCase()
  } function r(t, e) { return e && e !== p ? m.createElementNS(e, t) : m.createElement(t) } function a(t, e) { for (let n = t.firstChild; n;) { const i = n.nextSibling; e.appendChild(n), n = i } return e } function s(t, e) {
    let n; let i; let o; let r; let a; let
      s = e.attributes; for (n = s.length - 1; n >= 0; --n)i = s[n], o = i.name, r = i.namespaceURI, a = i.value, r ? (o = i.localName || o, t.getAttributeNS(r, o) !== a && t.setAttributeNS(r, o, a)) : t.getAttribute(o) !== a && t.setAttribute(o, a); for (s = t.attributes, n = s.length - 1; n >= 0; --n)i = s[n], i.specified !== !1 && (o = i.name, r = i.namespaceURI, r ? (o = i.localName || o, x(e, r, o) || t.removeAttributeNS(r, o)) : x(e, null, o) || t.removeAttribute(o))
  } function d(t, e, n) { t[n] !== e[n] && (t[n] = e[n], t[n] ? t.setAttribute(n, '') : t.removeAttribute(n, '')) } function u() { } function f(t) { return t.id } function l(t) {
    return function (e, n, s) {
      function d(t) { b ? b.push(t) : b = [t] } function l(t, e) { if (t.nodeType === S) for (let n = t.firstChild; n;) { let i = void 0; e && (i = z(n)) ? d(i) : (N(n), n.firstChild && l(n, e)), n = n.nextSibling } } function c(t, e, n) { M(t) !== !1 && (e && e.removeChild(t), N(t), l(t, n)) } function h(t) { if (t.nodeType === S) for (let e = t.firstChild; e;) { const n = z(e); n && (T[n] = e), h(e), e = e.nextSibling } } function p(t) {
        A(t); for (let e = t.firstChild; e;) {
          const n = e.nextSibling; const
            i = z(e); if (i) { const r = T[i]; r && o(e, r) && (e.parentNode.replaceChild(r, e), v(r, e)) } p(e), e = n
        }
      } function v(i, r, a) {
        let s; const
          u = z(r); if (u && delete T[u], !n.isSameNode || !n.isSameNode(e)) {
          if (!a) { if (_(i, r) === !1) return; if (t(i, r), C(i), R(i, r) === !1) return } if (i.nodeName !== 'TEXTAREA') {
            let f; let l; let h; let x; let b = r.firstChild; let
              A = i.firstChild; t: for (; b;) {
              for (h = b.nextSibling, f = z(b); A;) {
                if (l = A.nextSibling, b.isSameNode && b.isSameNode(A)) { b = h, A = l; continue t } s = z(A); const M = A.nodeType; let
                  N = void 0; if (M === b.nodeType && (M === S ? (f ? f !== s && ((x = T[f]) ? A.nextSibling === x ? N = !1 : (i.insertBefore(x, A), l = A.nextSibling, s ? d(s) : c(A, i, !0), A = x) : N = !1) : s && (N = !1), (N = N !== !1 && o(A, b)) && v(A, b)) : M !== I && M != y || (N = !0, A.nodeValue = b.nodeValue)), N) { b = h, A = l; continue t } s ? d(s) : c(A, i, !0), A = l
              } if (f && (x = T[f]) && o(x, b)) i.appendChild(x), v(x, b); else { const P = w(b); P !== !1 && (P && (b = P), b.actualize && (b = b.actualize(i.ownerDocument || m)), i.appendChild(b), p(b)) } b = h, A = l
            } for (; A;)l = A.nextSibling, (s = z(A)) ? d(s) : c(A, i, !0), A = l
          } const E = g[i.nodeName]; E && E(i, r)
        }
      } if (s || (s = {}), typeof n === 'string') if (e.nodeName === '#document' || e.nodeName === 'HTML') { const x = n; n = m.createElement('html'), n.innerHTML = x } else n = i(n); let b; var z = s.getNodeKey || f; var w = s.onBeforeNodeAdded || u; var A = s.onNodeAdded || u; var _ = s.onBeforeElUpdated || u; var C = s.onElUpdated || u; var M = s.onBeforeNodeDiscarded || u; var N = s.onNodeDiscarded || u; var R = s.onBeforeElChildrenUpdated || u; const P = s.childrenOnly === !0; var
        T = {}; h(e); let E = e; const O = E.nodeType; const
        L = n.nodeType; if (!P) if (O === S) L === S ? o(e, n) || (N(e), E = a(e, r(n.nodeName, n.namespaceURI))) : E = n; else if (O === I || O === y) { if (L === O) return E.nodeValue = n.nodeValue, E; E = n } if (E === n) N(e); else if (v(E, n, P), b) for (let F = 0, j = b.length; F < j; F++) { const D = T[b[F]]; D && c(D, D.parentNode, !1) } return !P && E !== e && e.parentNode && (E.actualize && (E = E.actualize(e.ownerDocument || m)), e.parentNode.replaceChild(E, e)), E
    }
  } let c; let h; var p = 'http://www.w3.org/1999/xhtml'; var m = typeof document === 'undefined' ? void 0 : document; const
    v = m ? m.body || m.createElement('div') : {}; h = v.hasAttributeNS ? function (t, e, n) { return t.hasAttributeNS(e, n) } : v.hasAttribute ? function (t, e, n) { return t.hasAttribute(n) } : function (t, e, n) { return t.getAttributeNode(e, n) != null }; var x = h; var g = { OPTION(t, e) { d(t, e, 'selected') }, INPUT(t, e) { d(t, e, 'checked'), d(t, e, 'disabled'), t.value !== e.value && (t.value = e.value), x(e, null, 'value') || t.removeAttribute('value') }, TEXTAREA(t, e) { const n = e.value; if (t.value !== n && (t.value = n), t.firstChild) { if (n === '' && t.firstChild.nodeValue === t.placeholder) return; t.firstChild.nodeValue = n } }, SELECT(t, e) { if (!x(e, null, 'multiple')) { for (var n = 0, i = e.firstChild; i;) { const o = i.nodeName; if (o && o.toUpperCase() === 'OPTION') { if (x(i, null, 'selected')) { n; break } n++ } i = i.nextSibling } t.selectedIndex = n } } }; var S = 1; var I = 3; var y = 8; const
    b = l(s); t.exports = b
}, function (t, e, n) { t.exports = n(1) }]))))
// # sourceMappingURL=virtualized-list.min.js.map
